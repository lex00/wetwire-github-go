package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
	"text/template"
)

// ActionWrapperConfig configures how an action wrapper is generated.
type ActionWrapperConfig struct {
	// ActionRef is the full action reference (e.g., "actions/checkout@v4")
	ActionRef string

	// PackageName is the Go package name (e.g., "checkout")
	PackageName string

	// TypeName is the Go struct name (e.g., "Checkout")
	TypeName string

	// Spec is the parsed action.yml
	Spec *ActionSpec
}

// GeneratedCode contains the result of code generation.
type GeneratedCode struct {
	PackageName string
	FileName    string
	Code        []byte
}

// Generator generates Go code from action specs.
type Generator struct{}

// NewGenerator creates a new Generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// actionWrapperTemplate is the template for generating action wrappers.
const actionWrapperTemplate = `// Code generated by wetwire-github codegen. DO NOT EDIT.

package {{.PackageName}}

import (
	"github.com/lex00/wetwire-github-go/workflow"
)

// {{.TypeName}} wraps the {{.ActionRef}} action.
{{- if .Spec.Description}}
// {{.Spec.Description}}
{{- end}}
type {{.TypeName}} struct {
{{- range .Fields}}
	// {{.Description}}
	{{.Name}} {{.Type}} ` + "`" + `yaml:"{{.YAMLName}},omitempty"` + "`" + `
{{- end}}
}

// Action returns the action reference.
func (a {{.TypeName}}) Action() string {
	return "{{.ActionRef}}"
}

// ToStep converts this action to a workflow step.
func (a {{.TypeName}}) ToStep() workflow.Step {
	with := make(workflow.With)
{{- range .Fields}}
{{- if eq .Type "string"}}
	if a.{{.Name}} != "" {
		with["{{.YAMLName}}"] = a.{{.Name}}
	}
{{- else if eq .Type "int"}}
	if a.{{.Name}} != 0 {
		with["{{.YAMLName}}"] = a.{{.Name}}
	}
{{- else if eq .Type "bool"}}
	if a.{{.Name}} {
		with["{{.YAMLName}}"] = a.{{.Name}}
	}
{{- end}}
{{- end}}
	return workflow.Step{
		Uses: a.Action(),
		With: with,
	}
}
`

// Field represents a field in the generated struct.
type Field struct {
	Name        string
	Type        string
	YAMLName    string
	Description string
	Required    bool
}

// templateData contains the data for the template.
type templateData struct {
	PackageName string
	TypeName    string
	ActionRef   string
	Spec        *ActionSpec
	Fields      []Field
}

// GenerateActionWrapper generates a Go wrapper for an action.
func (g *Generator) GenerateActionWrapper(config ActionWrapperConfig) (*GeneratedCode, error) {
	// Collect and sort fields
	fields := make([]Field, 0, len(config.Spec.Inputs))
	for name, input := range config.Spec.Inputs {
		fields = append(fields, Field{
			Name:        GetGoFieldName(name),
			Type:        inferGoType(input),
			YAMLName:    name,
			Description: sanitizeDescription(input.Description),
			Required:    input.Required,
		})
	}

	// Sort fields: required first, then alphabetically
	sort.Slice(fields, func(i, j int) bool {
		if fields[i].Required != fields[j].Required {
			return fields[i].Required
		}
		return fields[i].Name < fields[j].Name
	})

	data := templateData{
		PackageName: config.PackageName,
		TypeName:    config.TypeName,
		ActionRef:   config.ActionRef,
		Spec:        config.Spec,
		Fields:      fields,
	}

	tmpl, err := template.New("action").Parse(actionWrapperTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code with error context
		return nil, fmt.Errorf("formatting code: %w\n\nGenerated code:\n%s", err, buf.String())
	}

	return &GeneratedCode{
		PackageName: config.PackageName,
		FileName:    config.PackageName + ".go",
		Code:        formatted,
	}, nil
}

// inferGoType infers the Go type from an action input.
func inferGoType(input ActionInput) string {
	// Check default value for type hints
	if input.Default != "" {
		// Booleans
		if input.Default == "true" || input.Default == "false" {
			return "bool"
		}
		// Numbers (simple check)
		if isNumericDefault(input.Default) {
			return "int"
		}
	}

	// Check description for type hints
	desc := strings.ToLower(input.Description)
	if strings.Contains(desc, "number") || strings.Contains(desc, "count") ||
		strings.Contains(desc, "depth") || strings.Contains(desc, "timeout") {
		return "int"
	}
	if strings.Contains(desc, "whether") || strings.Contains(desc, "enable") ||
		strings.Contains(desc, "disable") {
		return "bool"
	}

	// Default to string
	return "string"
}

// isNumericDefault checks if a default value looks like a number.
func isNumericDefault(s string) bool {
	if s == "" {
		return false
	}
	for _, c := range s {
		if c < '0' || c > '9' {
			return false
		}
	}
	return true
}

// sanitizeDescription cleans up a description for use in Go comments.
func sanitizeDescription(desc string) string {
	// Remove newlines and extra spaces
	desc = strings.ReplaceAll(desc, "\n", " ")
	desc = strings.ReplaceAll(desc, "\r", "")
	desc = strings.Join(strings.Fields(desc), " ")

	// Truncate if too long
	if len(desc) > 100 {
		desc = desc[:97] + "..."
	}

	return desc
}

// GenerateActionWrapperFromYAML generates a wrapper from raw action.yml content.
func (g *Generator) GenerateActionWrapperFromYAML(yaml []byte, actionRef string) (*GeneratedCode, error) {
	spec, err := ParseActionYAML(yaml)
	if err != nil {
		return nil, fmt.Errorf("parsing action.yml: %w", err)
	}

	// Parse action reference to get owner/repo
	parts := strings.Split(actionRef, "/")
	if len(parts) < 2 {
		return nil, fmt.Errorf("invalid action reference: %s", actionRef)
	}

	// Extract repo name (without version)
	repoWithVersion := parts[1]
	repo := repoWithVersion
	if idx := strings.Index(repo, "@"); idx != -1 {
		repo = repo[:idx]
	}

	// Convert repo name to package/type names
	packageName := strings.ReplaceAll(repo, "-", "_")
	typeName := GetGoFieldName(repo)

	return g.GenerateActionWrapper(ActionWrapperConfig{
		ActionRef:   actionRef,
		PackageName: packageName,
		TypeName:    typeName,
		Spec:        spec,
	})
}
