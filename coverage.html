
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lex00/wetwire-github-go/internal/agent/agent.go (58.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package agent provides AI-assisted workflow generation using wetwire-core-go.
package agent

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/anthropics/anthropic-sdk-go"
        "github.com/anthropics/anthropic-sdk-go/option"
        "github.com/lex00/wetwire-core-go/agent/orchestrator"
        "github.com/lex00/wetwire-core-go/agent/results"
)

// GitHubAgent generates GitHub Actions workflows using the Anthropic API.
type GitHubAgent struct {
        client         anthropic.Client
        model          string
        session        *results.Session
        developer      orchestrator.Developer
        workDir        string
        generatedFiles []string
        maxLintCycles  int
        streamHandler  StreamHandler

        // Lint enforcement state
        lintCalled  bool
        lintPassed  bool
        pendingLint bool
        lintCycles  int
}

// StreamHandler is called for each text chunk during streaming.
type StreamHandler func(text string)

// Config configures the GitHubAgent.
type Config struct {
        // APIKey for Anthropic (defaults to ANTHROPIC_API_KEY env var)
        APIKey string

        // Model to use (defaults to claude-sonnet-4-20250514)
        Model string

        // WorkDir is the directory to write generated files
        WorkDir string

        // MaxLintCycles is the maximum number of lint/fix attempts
        MaxLintCycles int

        // Session for tracking results
        Session *results.Session

        // Developer to ask clarifying questions
        Developer orchestrator.Developer

        // StreamHandler is called for each text chunk during streaming
        StreamHandler StreamHandler
}

// NewGitHubAgent creates a new GitHubAgent.
func NewGitHubAgent(config Config) (*GitHubAgent, error) <span class="cov8" title="1">{
        apiKey := config.APIKey
        if apiKey == "" </span><span class="cov8" title="1">{
                apiKey = os.Getenv("ANTHROPIC_API_KEY")
        }</span>
        <span class="cov8" title="1">if apiKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ANTHROPIC_API_KEY environment variable not set")
        }</span>

        <span class="cov8" title="1">client := anthropic.NewClient(option.WithAPIKey(apiKey))

        if config.WorkDir == "" </span><span class="cov8" title="1">{
                config.WorkDir = "."
        }</span>
        <span class="cov8" title="1">if config.MaxLintCycles == 0 </span><span class="cov8" title="1">{
                config.MaxLintCycles = 5
        }</span>

        <span class="cov8" title="1">model := config.Model
        if model == "" </span><span class="cov8" title="1">{
                model = string(anthropic.ModelClaudeSonnet4_20250514)
        }</span>

        <span class="cov8" title="1">return &amp;GitHubAgent{
                client:        client,
                model:         model,
                session:       config.Session,
                developer:     config.Developer,
                workDir:       config.WorkDir,
                maxLintCycles: config.MaxLintCycles,
                streamHandler: config.StreamHandler,
        }, nil</span>
}

const systemPrompt = `You are a GitHub Actions workflow generator using the wetwire-github framework.
Your job is to generate Go code that defines GitHub Actions workflows.

The user will describe what CI/CD workflows they need. You will:
1. Ask clarifying questions if the requirements are unclear
2. Generate Go code using the wetwire-github patterns
3. Run the linter and fix any issues
4. Build the YAML output
5. Validate the generated YAML with actionlint

Use the wetwire-github patterns for all workflows:

    var CI = workflow.Workflow{
        Name: "CI",
        On:   CITriggers,
        Jobs: map[string]workflow.Job{
            "build": Build,
        },
    }

    var CITriggers = workflow.Triggers{
        Push:        &amp;workflow.PushTrigger{Branches: []string{"main"}},
        PullRequest: &amp;workflow.PullRequestTrigger{Branches: []string{"main"}},
    }

    var Build = workflow.Job{
        RunsOn: "ubuntu-latest",
        Steps:  BuildSteps,
    }

Use typed action wrappers instead of raw uses strings:
    checkout.Checkout{}
    setup_go.SetupGo{GoVersion: "1.23"}

Available tools:
- init_package: Create a new workflow project
- write_file: Write a Go file
- read_file: Read a file's contents
- run_lint: Run the wetwire-github linter
- run_build: Build the YAML workflows
- run_validate: Validate generated YAML with actionlint
- ask_developer: Ask the developer a clarifying question

Always run_lint after writing files, and fix any issues before running build.`

// Run executes the agent workflow.
func (a *GitHubAgent) Run(ctx context.Context, prompt string) error <span class="cov8" title="1">{
        tools := a.getTools()

        messages := []anthropic.MessageParam{
                anthropic.NewUserMessage(anthropic.NewTextBlock(prompt)),
        }

        // Agentic loop
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">params := anthropic.MessageNewParams{
                        Model:     anthropic.Model(a.model),
                        MaxTokens: 4096,
                        System:    []anthropic.TextBlockParam{{Text: systemPrompt}},
                        Messages:  messages,
                        Tools:     tools,
                }

                var resp *anthropic.Message
                var err error

                if a.streamHandler != nil </span><span class="cov0" title="0">{
                        resp, err = a.runWithStreaming(ctx, params)
                }</span> else<span class="cov0" title="0"> {
                        resp, err = a.client.Messages.New(ctx, params)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("API call failed: %w", err)
                }</span>

                <span class="cov0" title="0">messages = append(messages, resp.ToParam())

                if resp.StopReason == anthropic.StopReasonEndTurn </span><span class="cov0" title="0">{
                        if enforcement := a.checkCompletionGate(resp); enforcement != "" </span><span class="cov0" title="0">{
                                messages = append(messages, anthropic.NewUserMessage(
                                        anthropic.NewTextBlock(enforcement),
                                ))
                                continue</span>
                        }
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">if resp.StopReason == anthropic.StopReasonToolUse </span><span class="cov0" title="0">{
                        var toolResults []anthropic.ContentBlockParamUnion
                        var toolsCalled []string

                        for _, block := range resp.Content </span><span class="cov0" title="0">{
                                if block.Type == "tool_use" </span><span class="cov0" title="0">{
                                        result := a.executeTool(ctx, block.Name, block.Input)
                                        toolResults = append(toolResults, anthropic.NewToolResultBlock(
                                                block.ID,
                                                result,
                                                false,
                                        ))
                                        toolsCalled = append(toolsCalled, block.Name)
                                }</span>
                        }

                        <span class="cov0" title="0">messages = append(messages, anthropic.NewUserMessage(toolResults...))

                        if enforcement := a.checkLintEnforcement(toolsCalled); enforcement != "" </span><span class="cov0" title="0">{
                                messages = append(messages, anthropic.NewUserMessage(
                                        anthropic.NewTextBlock(enforcement),
                                ))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *GitHubAgent) runWithStreaming(ctx context.Context, params anthropic.MessageNewParams) (*anthropic.Message, error) <span class="cov0" title="0">{
        stream := a.client.Messages.NewStreaming(ctx, params)

        var message *anthropic.Message
        var contentBlocks []anthropic.ContentBlockUnion
        currentTextContent := make(map[int64]*strings.Builder)
        currentToolInput := make(map[int64]*strings.Builder)

        for stream.Next() </span><span class="cov0" title="0">{
                event := stream.Current()

                switch event.Type </span>{
                case "message_start":<span class="cov0" title="0">
                        startEvent := event.AsMessageStart()
                        message = &amp;startEvent.Message
                        contentBlocks = nil
                        currentTextContent = make(map[int64]*strings.Builder)</span>

                case "content_block_start":<span class="cov0" title="0">
                        startEvent := event.AsContentBlockStart()
                        if startEvent.ContentBlock.Type == "text" </span><span class="cov0" title="0">{
                                currentTextContent[startEvent.Index] = &amp;strings.Builder{}
                        }</span> else<span class="cov0" title="0"> if startEvent.ContentBlock.Type == "tool_use" </span><span class="cov0" title="0">{
                                currentToolInput[startEvent.Index] = &amp;strings.Builder{}
                        }</span>
                        <span class="cov0" title="0">block := anthropic.ContentBlockUnion{
                                Type: startEvent.ContentBlock.Type,
                                ID:   startEvent.ContentBlock.ID,
                                Name: startEvent.ContentBlock.Name,
                                Text: startEvent.ContentBlock.Text,
                        }
                        contentBlocks = append(contentBlocks, block)</span>

                case "content_block_delta":<span class="cov0" title="0">
                        deltaEvent := event.AsContentBlockDelta()
                        if deltaEvent.Delta.Type == "text_delta" &amp;&amp; deltaEvent.Delta.Text != "" </span><span class="cov0" title="0">{
                                a.streamHandler(deltaEvent.Delta.Text)
                                if builder, ok := currentTextContent[deltaEvent.Index]; ok </span><span class="cov0" title="0">{
                                        builder.WriteString(deltaEvent.Delta.Text)
                                }</span>
                        }
                        <span class="cov0" title="0">if deltaEvent.Delta.Type == "input_json_delta" &amp;&amp; deltaEvent.Delta.PartialJSON != "" </span><span class="cov0" title="0">{
                                if builder, ok := currentToolInput[deltaEvent.Index]; ok </span><span class="cov0" title="0">{
                                        builder.WriteString(deltaEvent.Delta.PartialJSON)
                                }</span>
                        }

                case "content_block_stop":<span class="cov0" title="0">
                        stopEvent := event.AsContentBlockStop()
                        idx := int(stopEvent.Index)
                        if idx &lt; len(contentBlocks) </span><span class="cov0" title="0">{
                                if builder, ok := currentTextContent[stopEvent.Index]; ok </span><span class="cov0" title="0">{
                                        contentBlocks[idx].Text = builder.String()
                                }</span>
                                <span class="cov0" title="0">if builder, ok := currentToolInput[stopEvent.Index]; ok </span><span class="cov0" title="0">{
                                        contentBlocks[idx].Input = json.RawMessage(builder.String())
                                }</span>
                        }

                case "message_delta":<span class="cov0" title="0">
                        deltaEvent := event.AsMessageDelta()
                        if message != nil </span><span class="cov0" title="0">{
                                message.StopReason = deltaEvent.Delta.StopReason
                                message.StopSequence = deltaEvent.Delta.StopSequence
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := stream.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if message != nil </span><span class="cov0" title="0">{
                message.Content = contentBlocks
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func (a *GitHubAgent) checkLintEnforcement(toolsCalled []string) string <span class="cov8" title="1">{
        wroteFile := false
        ranLint := false

        for _, tool := range toolsCalled </span><span class="cov8" title="1">{
                if tool == "write_file" </span><span class="cov8" title="1">{
                        wroteFile = true
                }</span>
                <span class="cov8" title="1">if tool == "run_lint" </span><span class="cov8" title="1">{
                        ranLint = true
                }</span>
        }

        <span class="cov8" title="1">if wroteFile &amp;&amp; !ranLint </span><span class="cov8" title="1">{
                return `ENFORCEMENT: You wrote a file but did not call run_lint in the same turn.
You MUST call run_lint immediately after writing code to check for issues.
Call run_lint now before proceeding.`
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func (a *GitHubAgent) checkCompletionGate(resp *anthropic.Message) string <span class="cov8" title="1">{
        var responseText string
        for _, block := range resp.Content </span><span class="cov8" title="1">{
                if block.Type == "text" </span><span class="cov8" title="1">{
                        responseText += block.Text
                }</span>
        }

        <span class="cov8" title="1">lowerText := strings.ToLower(responseText)
        isCompletionAttempt := strings.Contains(lowerText, "done") ||
                strings.Contains(lowerText, "complete") ||
                strings.Contains(lowerText, "finished") ||
                strings.Contains(lowerText, "that's it") ||
                strings.Contains(lowerText, "all set")

        if !isCompletionAttempt &amp;&amp; len(a.generatedFiles) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if !a.lintCalled </span><span class="cov8" title="1">{
                return `ENFORCEMENT: You cannot complete without running the linter.
You MUST call run_lint to validate your code before finishing.
Call run_lint now.`
        }</span>

        <span class="cov8" title="1">if a.pendingLint </span><span class="cov8" title="1">{
                return `ENFORCEMENT: You have written code since the last lint run.
You MUST call run_lint to validate your latest changes before finishing.
Call run_lint now.`
        }</span>

        <span class="cov8" title="1">if !a.lintPassed </span><span class="cov8" title="1">{
                return `ENFORCEMENT: The linter found issues that have not been resolved.
You MUST fix the lint errors and run_lint again until it passes.
Review the lint output and fix the issues.`
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func (a *GitHubAgent) getTools() []anthropic.ToolUnionParam <span class="cov8" title="1">{
        return []anthropic.ToolUnionParam{
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "init_package",
                                Description: anthropic.String("Initialize a new wetwire-github workflow project"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "name": map[string]any{
                                                        "type":        "string",
                                                        "description": "Project name (directory name)",
                                                },
                                        },
                                        Required: []string{"name"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "write_file",
                                Description: anthropic.String("Write content to a Go file"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "File path relative to work directory",
                                                },
                                                "content": map[string]any{
                                                        "type":        "string",
                                                        "description": "File content",
                                                },
                                        },
                                        Required: []string{"path", "content"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "read_file",
                                Description: anthropic.String("Read a file's contents"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "File path relative to work directory",
                                                },
                                        },
                                        Required: []string{"path"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "run_lint",
                                Description: anthropic.String("Run the wetwire-github linter on the project"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Project path to lint",
                                                },
                                        },
                                        Required: []string{"path"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "run_build",
                                Description: anthropic.String("Build the YAML workflows from the Go project"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Project path to build",
                                                },
                                        },
                                        Required: []string{"path"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "run_validate",
                                Description: anthropic.String("Validate generated YAML with actionlint"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Path to YAML file or directory",
                                                },
                                        },
                                        Required: []string{"path"},
                                },
                        },
                },
                {
                        OfTool: &amp;anthropic.ToolParam{
                                Name:        "ask_developer",
                                Description: anthropic.String("Ask the developer a clarifying question"),
                                InputSchema: anthropic.ToolInputSchemaParam{
                                        Properties: map[string]any{
                                                "question": map[string]any{
                                                        "type":        "string",
                                                        "description": "The question to ask",
                                                },
                                        },
                                        Required: []string{"question"},
                                },
                        },
                },
        }
}</span>

func (a *GitHubAgent) executeTool(ctx context.Context, name string, input json.RawMessage) string <span class="cov8" title="1">{
        var params map[string]string
        if err := json.Unmarshal(input, &amp;params); err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error parsing input: %v", err)
        }</span>

        <span class="cov8" title="1">switch name </span>{
        case "init_package":<span class="cov8" title="1">
                return a.toolInitPackage(params["name"])</span>
        case "write_file":<span class="cov8" title="1">
                return a.toolWriteFile(params["path"], params["content"])</span>
        case "read_file":<span class="cov8" title="1">
                return a.toolReadFile(params["path"])</span>
        case "run_lint":<span class="cov8" title="1">
                return a.toolRunLint(params["path"])</span>
        case "run_build":<span class="cov8" title="1">
                return a.toolRunBuild(params["path"])</span>
        case "run_validate":<span class="cov8" title="1">
                return a.toolRunValidate(params["path"])</span>
        case "ask_developer":<span class="cov8" title="1">
                answer, err := a.AskDeveloper(ctx, params["question"])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Error: %v", err)
                }</span>
                <span class="cov8" title="1">return answer</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("Unknown tool: %s", name)</span>
        }
}

func (a *GitHubAgent) toolInitPackage(name string) string <span class="cov8" title="1">{
        dir := filepath.Join(a.workDir, name)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error creating directory: %v", err)
        }</span>

        // Create basic go.mod
        <span class="cov8" title="1">goModContent := fmt.Sprintf(`module github.com/example/%s

go 1.23

require github.com/lex00/wetwire-github-go v0.0.0
`, name)
        goModPath := filepath.Join(dir, "go.mod")
        if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error writing go.mod: %v", err)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Created project directory: %s with go.mod", dir)</span>
}

func (a *GitHubAgent) toolWriteFile(path, content string) string <span class="cov8" title="1">{
        fullPath := filepath.Join(a.workDir, path)

        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error creating directory: %v", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error writing file: %v", err)
        }</span>

        <span class="cov8" title="1">a.generatedFiles = append(a.generatedFiles, path)
        a.pendingLint = true
        a.lintPassed = false

        return fmt.Sprintf("Wrote %d bytes to %s", len(content), path)</span>
}

func (a *GitHubAgent) toolReadFile(path string) string <span class="cov8" title="1">{
        fullPath := filepath.Join(a.workDir, path)
        content, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error reading file: %v", err)
        }</span>
        <span class="cov8" title="1">return string(content)</span>
}

func (a *GitHubAgent) toolRunLint(path string) string <span class="cov8" title="1">{
        fullPath := filepath.Join(a.workDir, path)
        cmd := exec.Command("wetwire-github", "lint", fullPath, "--format", "json")
        output, err := cmd.CombinedOutput()

        result := string(output)

        a.lintCalled = true
        a.pendingLint = false
        a.lintCycles++

        if err != nil </span><span class="cov8" title="1">{
                a.lintPassed = false
                if exitErr, ok := err.(*exec.ExitError); ok &amp;&amp; exitErr.ExitCode() == 2 </span><span class="cov0" title="0">{
                        var lintResult struct {
                                Success bool `json:"success"`
                                Issues  []struct {
                                        Message string `json:"message"`
                                } `json:"issues"`
                        }
                        if json.Unmarshal(output, &amp;lintResult) == nil &amp;&amp; a.session != nil </span><span class="cov0" title="0">{
                                issues := make([]string, len(lintResult.Issues))
                                for i, issue := range lintResult.Issues </span><span class="cov0" title="0">{
                                        issues[i] = issue.Message
                                }</span>
                                <span class="cov0" title="0">a.session.AddLintCycle(issues, a.lintCycles, false)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                a.lintPassed = true
                if a.session != nil </span><span class="cov0" title="0">{
                        a.session.AddLintCycle(nil, a.lintCycles, true)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func (a *GitHubAgent) toolRunBuild(path string) string <span class="cov8" title="1">{
        fullPath := filepath.Join(a.workDir, path)
        cmd := exec.Command("wetwire-github", "build", fullPath, "--format", "yaml")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Build error: %s\n%s", err, output)
        }</span>
        <span class="cov0" title="0">return string(output)</span>
}

func (a *GitHubAgent) toolRunValidate(path string) string <span class="cov8" title="1">{
        fullPath := filepath.Join(a.workDir, path)
        cmd := exec.Command("wetwire-github", "validate", fullPath, "--format", "json")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Validation issues:\n%s", output)
        }</span>
        <span class="cov0" title="0">return string(output)</span>
}

// AskDeveloper sends a question to the Developer.
func (a *GitHubAgent) AskDeveloper(ctx context.Context, question string) (string, error) <span class="cov8" title="1">{
        if a.developer == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no developer configured")
        }</span>

        <span class="cov8" title="1">answer, err := a.developer.Respond(ctx, question)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if a.session != nil </span><span class="cov8" title="1">{
                a.session.AddQuestion(question, answer)
        }</span>

        <span class="cov8" title="1">return answer, nil</span>
}

// GetGeneratedFiles returns the list of generated file paths.
func (a *GitHubAgent) GetGeneratedFiles() []string <span class="cov8" title="1">{
        return a.generatedFiles
}</span>

// GetLintCycles returns the number of lint attempts.
func (a *GitHubAgent) GetLintCycles() int <span class="cov8" title="1">{
        return a.lintCycles
}</span>

// LintPassed returns whether the last lint run passed.
func (a *GitHubAgent) LintPassed() bool <span class="cov8" title="1">{
        return a.lintPassed
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
